| CS-665       | Software Design & Patterns |
|--------------|----------------------------|
| Name         | Qiong Wang                 |
| Date         | 10/13/2024                 |
| Course       | Fall                       |
| Assignment # | Hw2 Delivery System        |

# Assignment Overview
This project is part of CS-665: Software Designs and Patterns. The goal is to develop a notification system for a collection of retailers who collaborate with freelance drivers (van, taxi, scooter) for the delivery of products to customers. The system informs drivers about delivery requests by broadcasting notifications when a product delivery order is generated by a store.

The project requires the implementation of the following components:
- **Shop**: Represents a store that generates delivery requests.
- **DeliveryRequest**: Encapsulates the details of a product delivery order.
- **Driver**: Represents freelance drivers who are notified about delivery requests.

### Key Requirements:
1. Create instances of `Shop`, `DeliveryRequest`, and at least five `Driver` objects.
2. Upon generating a delivery request, the request must be broadcast to all available drivers.
3. Unit tests are required to demonstrate the functionality (3-5 JUnit tests).
4. At least one design pattern (such as **Observer Pattern**) must be applied to the system.


# GitHub Repository Link:
(https://github.com/QiongWang1/CS665_Hw2)


# Implementation Description

This project implements a notification system for retailers to communicate delivery requests to freelance drivers using the **Observer Pattern**. The system consists of three main components: `Shop`, `Driver`, and `DeliveryRequest`, which interact to broadcast delivery notifications when a new request is created.

### Key Components:
1. **Shop**: The `Shop` class represents a store that can generate delivery requests. It maintains a list of registered drivers (observers) and notifies them whenever a new delivery request is created.
   - **Methods**:
      - `addDriver(Driver driver)`: Registers a driver to the shop.
      - `createDeliveryRequest(String product, String destination)`: Generates a delivery request and notifies all registered drivers.
      - `notifyDrivers(DeliveryRequest request)`: Sends the delivery request to all drivers.

2. **Driver**: The `Driver` class represents a freelance driver who can receive notifications from shops about new delivery requests.
   - **Methods**:
      - `notify(DeliveryRequest request)`: Receives a notification of a delivery request, including details such as the product and destination.

3. **DeliveryRequest**: This class encapsulates the details of a delivery request, including the product to be delivered and the destination.


### Design Pattern:
The project applies the **Observer Pattern**:
- **Shop (Publisher)**: Acts as the subject that broadcasts delivery requests to the drivers.
- **Driver (Observer)**: Listens for delivery requests from the shop and processes them when notified.


### System Flow:
1. The `Shop` registers multiple `Driver` objects.
2. When the `Shop` creates a new `DeliveryRequest`, it automatically notifies all registered `Driver` objects using the `notifyDrivers()` method.
3. Each `Driver` then processes the delivery request by printing the details of the request.


### Unit Tests:
The functionality of the system is verified using JUnit tests:
- **testAddDriver()**: Verifies that drivers are successfully added to the shop.
- **testCreateDeliveryRequest()**: Ensures that all drivers receive the delivery request notification.
- **testNoDriversRegistered()**: Confirms that no notifications are sent if no drivers are registered.


### Assumptions:
- The system assumes that drivers are registered before delivery requests are made.
- Notifications are sent to all drivers simultaneously, and no filtering of drivers (e.g., based on proximity) is implemented in this version.


## Flexibility
The system is designed with flexibility in mind to accommodate future changes and additions without requiring significant refactoring. The use of the **Observer Pattern** allows easy addition of new types of drivers or stores without changing the existing codebase.
- **Adding New Driver Types**: The system can easily support new types of drivers (e.g., bike couriers or drone deliveries) by simply extending the `Driver` class, without needing to modify the `Shop` or `DeliveryRequest` classes.
- **Extending Shop Functionality**: The `Shop` class can be extended to include new functionalities such as prioritizing certain drivers or sending notifications based on specific criteria (e.g., driver proximity or delivery capacity) with minimal changes to the existing code.
- **Decoupled Notifications**: The `Shop` and `Driver` classes are decoupled, meaning any changes in one do not affect the other as long as they adhere to the notification protocol.


## Simplicity & Understandability
The system is designed to be simple and intuitive, with clearly defined roles for each class:
- **Shop**: Acts as a central hub for managing drivers and broadcasting delivery requests.
- **Driver**: Represents an individual who responds to delivery notifications.
- **DeliveryRequest**: Encapsulates the details of a specific delivery.
Each class focuses on a single responsibility, which makes the system easier to understand, modify, and extend. By adhering to common design principles such as the **Single Responsibility Principle (SRP)**, the system avoids unnecessary complexity. The usage of well-known design patterns like **Observer Pattern** enhances the overall understandability for developers familiar with such patterns.


## Avoidance of Duplicated Code
To maintain a clean and maintainable codebase, the project follows the **DRY (Don't Repeat Yourself)** principle. Here are some key strategies used to avoid code duplication:
- **Reusable Components**: The `Driver` and `DeliveryRequest` classes are designed to be reusable across multiple instances. Each `Shop` can register multiple drivers and broadcast delivery requests without duplicating the logic.
- **Notification System**: The `notifyDrivers()` method in `Shop` ensures that the delivery notification process is centralized, preventing the need to duplicate this logic for each individual driver.
- **Single Source of Truth**: All drivers are stored in a list within the `Shop` class, ensuring that the same instance of each driver is used consistently throughout the system.


## Design Patterns Used
This project leverages the **Observer Pattern** to manage notifications between the `Shop` and `Driver` classes:
- **Observer Pattern**: This pattern is implemented to allow the `Shop` (as the publisher) to broadcast delivery requests to all registered `Driver` objects (as observers). When a `DeliveryRequest` is created, the `Shop` automatically notifies all drivers, decoupling the sender of the request from the receivers.

### Other Potential Design Patterns:
- **Factory Method**: Although not implemented in this version, the `Shop` class could use the **Factory Method Pattern** to create different types of delivery requests or drivers in the future, making the system more extensible.
- **Decorator Pattern**: The system could also use the **Decorator Pattern** to add additional features to `Driver` objects, such as special delivery capabilities or additional notification preferences.


# UML Class Diagram
(https://lucid.app/lucidchart/f289615f-1111-4800-95b2-9018957d979b/edit?viewport_loc=-449%2C-638%2C3527%2C2329%2C0_0&invitationId=inv_225189b0-b5d0-4c3d-bd1d-96575a0d500c)
![img.png](img.png)



# Running JUnit Tests

To verify the functionality of the system, JUnit tests have been implemented to test the core components of the project. These tests ensure that the system behaves as expected under various conditions.

### Steps to Run the JUnit Tests:

1. **Compile the Project**:
   First, ensure the project is compiled. You can do this using Maven:
   ```bash
   mvn clean compile




# Maven Commands

This project uses Maven for building, compiling, and running tests. Below are the essential Maven commands that you can use to manage the project:

### 1. Compile the Project

To compile the project and ensure that the source code is error-free, run the following command:

```bash
mvn clean compile

